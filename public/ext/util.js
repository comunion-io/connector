// Generated by CoffeeScript 2.3.2
var checkEt, crypto;

crypto = require('crypto');

checkEt = function(it) {
  var k, results, v;
  it.password && delete it.password;
  results = [];
  for (k in it) {
    v = it[k];
    if (_.isObject(v)) {
      results.push(checkEt(v));
    } else {
      if (v === 'false') {
        results.push(it[k] = false);
      } else if (v === 'true') {
        results.push(it[k] = true);
      } else {
        results.push(void 0);
      }
    }
  }
  return results;
};

module.exports = {
  moPath: function(code) {
    var path;
    path = `/public/module/${code}`;
    if (app.env) {
      return '.' + path;
    } else {
      return _path + path;
    }
  },
  sPath: function(code) {
    var path;
    path = `/public/res/upload/${code}`;
    if (app.env) {
      return '.' + path;
    } else {
      return _path + path;
    }
  },
  sha256: function(str) {
    return crypto.createHash('sha256').update(str).digest('base64');
  },
  d: function(it, p) {
    var rs;
    rs = it[p];
    delete it[p];
    return rs;
  },
  r: function(it, extra, e) {
    var i, len, t;
    if (_.isArray(it)) {
      for (i = 0, len = it.length; i < len; i++) {
        t = it[i];
        checkEt(t);
      }
      return {
        entities: it,
        count: extra || it.length
      };
    } else if (it) {
      checkEt(it);
      return {
        entity: it,
        msg: extra,
        _e: e
      };
    } else {
      return {
        _e: e,
        msg: 'm_find_no'
      };
    }
  },
  refFile: function(ob, key = 'head', idx = 0) {
    var rf;
    rf = ob.refFile;
    if (rf && rf[key] && rf[key].length) {
      if (idx != null) {
        return rf[key][idx];
      } else {
        return rf[key];
      }
    } else {
      return null;
    }
  },
  dly: function(t = 3) {
    var r;
    t *= 1000;
    r = parseInt(Math.random() * t / 2);
    if (r % 2 === 0) {
      t += r;
    } else {
      t -= r;
    }
    return new Promise(function(resolve) {
      return setTimeout(resolve, t);
    });
  }
};
